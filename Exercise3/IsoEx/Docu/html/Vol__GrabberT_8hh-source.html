<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IsoEx: Vol_GrabberT.hh Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6-20040222 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>Vol_GrabberT.hh</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef VOL_GRABBERT_HH</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define VOL_GRABBERT_HH</span>
00003 <span class="preprocessor"></span>
00004 <span class="preprocessor">#include &lt;iostream&gt;</span>
00005 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00006 
00007 <span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>
00008 <span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/TriMeshT.hh&gt;</span>
00009 
00010 <span class="comment">// ACG</span>
00011 <span class="preprocessor">#include &lt;ACG/Geometry/Algorithms.hh&gt;</span>
00012 
00013 <span class="preprocessor">#include "HelperVolume.hh"</span>
00014 
00015 <span class="preprocessor">#define Epsilon 0.001</span>
00016 <span class="preprocessor"></span>
00017 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MyMesh,  <span class="keyword">class</span> Volume&gt;
00018 <span class="keyword">class </span>Vol_GrabberT
00019 {
00020 <span class="keyword">public</span>:
00021 
00022   <span class="comment">// default constructor</span>
00023   Vol_GrabberT(MyMesh&amp; _mesh) : epsilon_(1), mesh_(_mesh) { }
00024 
00025   ~Vol_GrabberT() {}
00026 
00027   <span class="keywordtype">void</span> set_mesh(MyMesh&amp; _mesh) { mesh_ = _mesh;}
00028   
00029   <span class="keyword">inline</span> <span class="keywordtype">void</span> set_epsilon(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _e) { epsilon_ = _e;  }
00030  
00031   <span class="keywordtype">void</span> render_into_volume(Volume&amp; _volume ,HelperVolume&amp; _helper);
00032   
00033 <span class="keyword">private</span>:
00034 
00035   <span class="keyword">typedef</span> <span class="keyword">typename</span> MyMesh::FaceVertexIter FaceVertexIter;
00036   <span class="keyword">typedef</span> <span class="keyword">typename</span> MyMesh::VertexIter VertexIter;
00037   <span class="keyword">typedef</span> <span class="keyword">typename</span> MyMesh::FaceIter FaceIter;
00038   <span class="keyword">typedef</span> <span class="keyword">typename</span> MyMesh::VertexFaceIter VertexFaceIter;
00039   <span class="keyword">typedef</span> <span class="keyword">typename</span> MyMesh::FaceHandle FaceHandle;
00040   <span class="keyword">typedef</span> <span class="keyword">typename</span> MyMesh::VertexHandle VertexHandle;
00041 
00042   OpenMesh::VPropHandleT&lt;typename MyMesh::Normal&gt; angle_normal;
00043 
00044   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> epsilon_;
00045   MyMesh&amp; mesh_;
00046 
00047   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xres, yres, zres;
00048 
00049   <span class="keyword">typedef</span> <span class="keyword">typename</span> Volume::Scalar Scalar;
00050   <span class="keyword">typedef</span> OpenMesh::VectorT&lt;Scalar,3&gt; Point;
00051 
00052   <span class="comment">//-----------------------------------------------------------------------</span>
00053   <span class="keywordtype">void</span> update_angle_weighted_vertex_normals();
00054 
00055   <span class="keyword">inline</span> <span class="keywordtype">void</span> get_triangle_bb(Point p0, Point p1, Point p2, 
00056                               OpenMesh::Vec3i &amp;_bbmin,
00057                               OpenMesh::Vec3i &amp;_bbmax)
00058   {
00059 
00060     Point tmpbbmin(p0), tmpbbmax(p0);
00061     tmpbbmin.minimize(p1); tmpbbmin.minimize(p2);
00062     tmpbbmax.maximize(p1); tmpbbmax.maximize(p2);
00063     
00064     _bbmin = OpenMesh::Vec3i((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(floor(tmpbbmin[0])), 
00065                              (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(floor(tmpbbmin[1])), 
00066                              (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(floor(tmpbbmin[2]))); 
00067     _bbmax = OpenMesh::Vec3i((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(ceil(tmpbbmax[0])),
00068                              (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(ceil(tmpbbmax[1])),
00069                              (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(ceil(tmpbbmax[2]))); 
00070   }
00071 
00072 
00073   <span class="keywordtype">void</span> bounding_box(Point &amp;_BBMin, Point &amp;_BBMax)
00074   {
00075     VertexIter v_it(mesh_.vertices_begin()), v_end(mesh_.vertices_end());
00076     
00077     _BBMin = mesh_.point(v_it.handle());
00078     _BBMax = mesh_.point(v_it.handle());
00079 
00080     <span class="keywordflow">for</span> (; v_it != v_end; ++v_it)
00081     {
00082       Point p = mesh_.point(v_it.handle());
00083       _BBMin.minimize(p);
00084       _BBMax.maximize(p);
00085     }
00086   }
00087 
00088   <span class="keyword">inline</span> Scalar maximum(Scalar a, Scalar b, Scalar c)
00089   {
00090     <span class="keywordflow">if</span> (a &gt; b &amp;&amp; a &gt; c) <span class="keywordflow">return</span> a;
00091     <span class="keywordflow">if</span> (b &gt; a &amp;&amp; b &gt; c) <span class="keywordflow">return</span> b;
00092     <span class="keywordflow">return</span> c;
00093   }
00094 
00095   <span class="keyword">inline</span> Point mat_mult(Point z1, Point z2, Point z3, Point x)
00096   {
00097     <span class="keywordflow">return</span> Point(z1 | x,  z2 | x,  z3 | x);
00098   };
00099 
00100 
00101 };
00102 
00103 
00104 <span class="comment">//-- Implementation of special normals and main procedure --------------------</span>
00105 
00106 
00107 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MyMesh, <span class="keyword">class</span> Volume&gt;
00108 <span class="keywordtype">void</span> Vol_GrabberT&lt; MyMesh, Volume &gt;::
00109 update_angle_weighted_vertex_normals()
00110 {
00111 
00112   VertexIter v_it, <a class="code" href="classIsoEx_1_1Grid.html#z1_1">end</a> = mesh_.vertices_end();
00113   <span class="keywordflow">for</span> (v_it = mesh_.vertices_begin(); v_it != end; ++v_it)
00114   {
00115     Point <a class="code" href="classIsoEx_1_1RegularGrid.html#a5">point</a> = mesh_.point(v_it.handle());
00116     Point final_normal(0,0,0);
00117     Scalar angle_sum = 0;
00118     
00119     VertexFaceIter vf_it; 
00120     <span class="keywordflow">for</span> (vf_it = mesh_.vf_iter(v_it.handle()); vf_it; ++vf_it)
00121     {
00122       FaceVertexIter fv_it = mesh_.fv_iter(vf_it.handle());
00123       Point p0 = mesh_.point(fv_it.handle()); ++fv_it;
00124       Point p1 = mesh_.point(fv_it.handle()); ++fv_it;
00125       Point p2 = mesh_.point(fv_it.handle());
00126 
00127       Point normal = mesh_.normal(vf_it);
00128       
00129       Scalar angle; Point e1, e2;
00130       
00131       <span class="keywordflow">if</span> (p0 == point) { e1 = p1-p0; e2 = p2-p0; }
00132       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p1 == point) { e1 = p0-p1; e2 = p2-p1; }
00133       <span class="keywordflow">else</span> { e1 = p0-p2; e2 = p1-p2; }
00134       
00135       angle = acos(std::min((Scalar)1.0, 
00136                             std::max((Scalar)-1.0, 
00137                                      (e1|e2)/(e1.norm()*e2.norm()))));
00138       final_normal += angle*normal;
00139       angle_sum += angle;
00140     }
00141     final_normal.normalize();
00142     mesh_.property(angle_normal, v_it.handle()) = final_normal;
00143   }
00144 }
00145 
00146 <span class="comment">//-----------------------------------------------------------------------------</span>
00147 
00148 <span class="keyword">template</span> &lt; <span class="keyword">class</span> MyMesh, <span class="keyword">class</span> Volume&gt;
00149 <span class="keywordtype">void</span> Vol_GrabberT&lt; MyMesh ,Volume &gt;::
00150 render_into_volume(Volume&amp; _volume, HelperVolume&amp; _helper)
00151 {
00152   
00153   <span class="comment">// register vertex property storing angle weighted vertex normals</span>
00154   mesh_.add_property( angle_normal );
00155   
00156   Point z1 ,z2 ,z3, t; <span class="comment">// Matrix-rows, Translation</span>
00157 
00158   <span class="comment">// bbmin + x_vec * i + y_vec * j + z_vec * k ( vol_points   )</span>
00159   <span class="comment">// -&gt; invers:  compute basis transform</span>
00160   
00161   Point x_unit_dir = _volume.x_axis()/Scalar( _volume.x_resolution() -1);
00162   Point y_unit_dir = _volume.y_axis()/Scalar( _volume.y_resolution() -1);
00163   Point z_unit_dir = _volume.z_axis()/Scalar( _volume.z_resolution() -1);
00164 
00165   <span class="comment">// ?? -1</span>
00166 
00167   z1 =  x_unit_dir / (x_unit_dir | x_unit_dir );
00168   z2 =  y_unit_dir / (y_unit_dir | y_unit_dir );
00169   z3 =  z_unit_dir / (z_unit_dir | z_unit_dir );
00170   
00171   t = mat_mult(z1, z2, z3 ,-_volume.origin());
00172  
00173   Scalar voxel_diag_squared = (x_unit_dir | x_unit_dir );
00174 
00175   <span class="comment">//init volume</span>
00176   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; _volume.x_resolution(); ++i) 
00177     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; _volume.y_resolution(); ++j) 
00178       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; _volume.z_resolution(); ++k)
00179         _volume(i,j,k) = FLT_MAX ;
00180  
00181   <span class="comment">// computing special normals for sign determination</span>
00182   update_angle_weighted_vertex_normals();
00183   
00184   <span class="comment">// compute distances</span>
00185 
00186   OpenMesh::Vec3i bb_tri_min, bb_tri_max;
00187 
00188   FaceIter f_it, f_end = mesh_.faces_end();
00189 
00190   <span class="keywordflow">for</span> (f_it = mesh_.faces_begin(); f_it != f_end; ++f_it)
00191   {
00192     FaceHandle fh = f_it.handle();
00193     Point tri_normal;
00194     FaceVertexIter fv_it = mesh_.fv_iter(fh);
00195     VertexHandle vh0, vh1, vh2; 
00196     
00197     vh0 = fv_it.handle(); 
00198     Point p0 = mat_mult(z1, z2, z3, mesh_.point(vh0)) + t; ++fv_it;
00199     Point p0_v = mesh_.point(vh0);
00200     vh1 = fv_it.handle(); 
00201     Point p1 = mat_mult(z1, z2, z3, mesh_.point(vh1)) + t; ++fv_it;
00202     Point p1_v = mesh_.point(vh1);
00203     vh2 = fv_it.handle();
00204     Point p2 = mat_mult(z1, z2, z3, mesh_.point(vh2)) + t; 
00205     Point p2_v = mesh_.point(vh2);
00206     
00207     
00208     <span class="comment">// calculate triangle BB</span>
00209     get_triangle_bb(p0, p1, p2, bb_tri_min, bb_tri_max);
00210     
00211     <span class="comment">// compute max in unit-dimensions</span>
00212     <span class="keywordtype">int</span> minx = bb_tri_min[0] - epsilon_;
00213     <span class="keywordtype">int</span> miny = bb_tri_min[1] - epsilon_; 
00214     <span class="keywordtype">int</span> minz = bb_tri_min[2] - epsilon_;
00215       
00216     <span class="keywordtype">int</span> maxx = bb_tri_max[0] + epsilon_;
00217     <span class="keywordtype">int</span> maxy = bb_tri_max[1] + epsilon_;
00218     <span class="keywordtype">int</span> maxz = bb_tri_max[2] + epsilon_;
00219             
00220     <span class="comment">// check that epsilon BB does not extend beyond volume limits</span>
00221     <span class="keywordflow">if</span> (minx &lt; 0) minx = 0; <span class="keywordflow">if</span> (miny &lt; 0) miny = 0; <span class="keywordflow">if</span> (minz &lt; 0) minz = 0;
00222     <span class="keywordflow">if</span> (maxx &gt;= (<span class="keywordtype">int</span>)_volume.x_resolution()) maxx = _volume.x_resolution() - 1; 
00223     <span class="keywordflow">if</span> (maxy &gt;= (<span class="keywordtype">int</span>)_volume.y_resolution()) maxy = _volume.y_resolution() - 1; 
00224     <span class="keywordflow">if</span> (maxz &gt;= (<span class="keywordtype">int</span>)_volume.z_resolution()) maxz = _volume.z_resolution() - 1;
00225 
00226       
00227     <span class="comment">// for every voxel in the BB, calculate distance value to the triangle</span>
00228    
00229     Point nearest;  <span class="comment">// nearest on triangle</span>
00230 
00231     <span class="comment">// for all voxels in extended bounding box</span>
00232     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = minx; x &lt;= maxx; x++)
00233       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = miny; y &lt;= maxy; y++)
00234         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> z = minz; z &lt;= maxz; z++)
00235         {                 
00236           <span class="comment">//Point voxel_center(x+0.5, y+0.5, z+0.5);</span>
00237           <span class="comment">// Scalar Grid errechnet distances nicht im center sondern auf grid</span>
00238           
00239           Point voxel_center(x, y, z);
00240           voxel_center = _volume.origin() + 
00241             Scalar(x) * _volume.x_axis() /Scalar(_volume.x_resolution()-1) +
00242             Scalar(y) * _volume.y_axis() /Scalar(_volume.y_resolution()-1) + 
00243             Scalar(z) * _volume.z_axis() /Scalar(_volume.z_resolution()-1);
00244 
00245           
00246           Scalar d = ACG::Geometry::distPointTriangleSquared (voxel_center,
00247                                                               p0_v,p1_v,p2_v,
00248                                                               nearest);
00249           
00250           <span class="keywordflow">if</span> (d &lt; voxel_diag_squared) <span class="comment">// &gt; max dist in voxel</span>
00251           {
00252             d = sqrt (d);
00253             
00254             <span class="comment">// test if inner or outer by using angle normals</span>
00255             <span class="keywordflow">if</span> (fabs(d) &lt; fabs (_volume(x,y,z)) )
00256             {
00257               <span class="comment">// sign decision:</span>
00258               Point barys;
00259               ACG::Geometry::baryCoord( nearest,
00260                                         p0_v, p1_v, p2_v,
00261                                         barys );
00262               
00263               tri_normal = barys[0] * mesh_.property(angle_normal, vh0) +
00264                            barys[1] * mesh_.property(angle_normal, vh1) +
00265                            barys[2] * mesh_.property(angle_normal, vh2);
00266 
00267               tri_normal.normalize();
00268               
00269               Point diff_vec = nearest - voxel_center;
00270               
00271               Scalar sign_ = diff_vec | tri_normal;
00272              
00273               <span class="keywordflow">if</span> (sign_ &gt;= 0.0)
00274                 _volume(x,y,z) = -d;
00275               <span class="keywordflow">else</span> _volume(x,y,z) = d;
00276               _helper(x,y,z).set_conquered(<span class="keyword">true</span>);
00277             };
00278           };
00279         };
00280   }; 
00281   <span class="comment">// initial values computed !!</span>
00282 
00283   mesh_.remove_property( angle_normal );
00284 };
00285 
00286 
00287 <span class="preprocessor">#endif // VOL_GRABBERT_HH</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jul 5 18:07:08 2004 for IsoEx by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > </a>1.3.6-20040222 </small></address>
</body>
</html>
